% fitPRFs.m
%
% Fits the population receptive field model to optical imaging mouse data.
% This script needs the data file 'CompiledData', generated by the script
% 'CompileData.m'
% 

function [RFx, RFy, RFsig, r, xVoxRange, yVoxRange] = ...
    fitPRFs(S, R, t, phi, theta, nRows, nCols)
% 9/9/15 not save RFbest due to restriction of parfor

%%
% Define the impulse response function.  (the term 'HDR' is used here as a
% throwback to the fMRI 'hemodynamic response function'.

t(1) = t(2)-(t(3)-t(2));
% sRate = median(diff(t)); %[s]
% t = 0:sRate:19*sRate;

% Parameters for the differerence of Gamma functions.  These were derived
% by fitting the model to the pulse data that you guys supplied me.  I'm
% happy to share that code too of course.

n1 =3;
k1 = 26.7532/1000;
delay1 = 31.8031/1000;

a = .2728;%.15;
n2 =5;
k2 = 21.0351/1000;
delay2 = 88.5876/1000;

tHDR = t(1:20)-min(t); %20x1 array
%hdr = gammaPDF(n1,k1,tHDR-delay1)- a*gammaPDF(n2,k2,tHDR-delay2);%gammaPDF is missing
hdr = pdf('gamma',tHDR-delay1, n1, k1) - a*pdf('gamma',tHDR-delay2, n2, k2);%20x1 array

figure(1)
clf
plot(tHDR*1000,hdr,'k-');


%% 
% Convolve the stimulus with the impulse response function.  Predicted
% responses are made by multiplying the Gaussian receptive field with the
% stimulus for each time-course and then convolving with the impulse
% response function.  But since these are linear processes, we can convolve
% the stimulus with the impulse response function first, which speeds
% things up.


tmpS = conv2(S,hdr);  %delay by three frames
tmpS = tmpS(1:(size(S,1)),:);
S = tmpS;
xlabel('Time (ms)')
ylabel('Reponse');



%%
% Generate a set of initial pRFs to determine the initial parameters for
% nonlinear optimization.

[x,y] = meshgrid(phi,theta);
nx= length(phi);
ny = length(theta);
r = sqrt(x.^2+y.^2);

nAng = 16;  %number of polar angles
radList = linspace(.1,2,16);  %number of eccentricities

[angList,radList] = meshgrid(linspace(-pi/2,pi/2,nAng),radList);
sigList = (radList+.05)/4;  %corresponding list of sigmas (RF sizes)

%Columns of 'R' will hold the unwrapped Gaussian pRFs
G  = zeros(nx*ny,length(radList));
img = zeros(ny,nx);
clear baseRF
for i = 1:length(radList(:));
    rad= radList(i);
    ang = angList(i);
    sig = sigList(i);
    
    xc = rad*cos(ang);
    yc = rad*sin(ang);
    baseRF(i).center = [xc,yc];
    
    baseRF(i).sig = sig;
    baseRF(i).shutup = 1;
    tmp =  Gauss(baseRF(i),x,y);
    G(:,i) = tmp(:);
end

%% 
% Generate predicted responses for each possible receptive field to the
% stimulus.  This is a simple matrix multiplication:
predResp = S*G;

%%
% Correlation threshold for showing results.  
cothresh = 0.25;

% To speed things up for testing you can fit a subset of pixels (The term
% 'voxel' is often used as a throwback to fMRI)

xVoxRange = [1:nCols];
yVoxRange = [1:nRows];

clear RFbest RFx RFy RFsig r

close all

% h = waitbar(0,'Time left');
% tic

% Loop through each pixel of the data and find the center and size for the
% best-fitting Gaussian population receptive field.

RFx = nan(length(yVoxRange),length(xVoxRange));
RFy = nan(length(yVoxRange),length(xVoxRange));
RFsig = nan(length(yVoxRange),length(xVoxRange));
r = nan(length(yVoxRange),length(xVoxRange));
parfor xCount = 1:length(xVoxRange)
    xVox = xVoxRange(xCount);    
    
    RFx_temp = nan(length(yVoxRange), 1);
    RFy_temp = nan(length(yVoxRange), 1);
    RFsig_temp = nan(length(yVoxRange), 1);
    r_temp = nan(length(yVoxRange), 1);

    for yCount= 1:length(yVoxRange)
        yVox = yVoxRange(yCount);        
        voxNum = sub2ind([nRows,nCols],yVox,xVox);      
        
        % This is the time-course for the current pixel 
        voxResp = R(:,voxNum); %R is indeed huge!! how does parfor deal with this? should use spmd?
        
        % correlate this time-course with the predicted reponses to the
        % initial set of RFs.
        err = zeros(1,size(predResp,2));
        for i=1:size(predResp,2)
            err(i) = corr(voxResp,predResp(:,i));
            %err(i) = -tmp(1,2);
        end
        
        
        %find the best one and show in figure 1
        %[tmp,id] = min(err);
        [tmp,id] = max(err); %11/9/15 DS modified from min
        
        %  RFbest(yCount,xCount)= fit('fitGauss',baseRF(id),{'center','sig'},S,voxResp,x,y);
        
        RFstart = baseRF(id);
        RFstart.a = 1;
        RFstart.theta = 0;
        
        
        RFstart= fit('fitGauss',RFstart,{'center','sig'},S,voxResp,x,y);
        %         RFstart= fit('fitGauss',RFstart,{'a','theta'},S,voxResp,x,y);
        %         RFstart= fit('fitGauss',RFstart,{'center','sig','a','theta'},S,voxResp,x,y);
        RFbest = RFstart;
        
        
        
        bestG =  Gauss(RFbest,x,y);
        bestResp = S*bestG(:);
        tmp = corrcoef(bestResp,voxResp);
        
        disp(sprintf('(%d,%d), xc = %5.2f, yc = %5.2f, sig = %5.2f, a = %5.2f, theta = %5.2f, err= %5.4f ',...
            xVox,yVox,...
            RFbest.center(1),...
            RFbest.center(2),...
            RFbest.sig,...
            RFbest.a,...
            RFbest.theta*180/pi,...
            tmp(1,2)));
        
        RFx_temp(yCount) = RFbest.center(1);
        RFy_temp(yCount) = RFbest.center(2);
        RFsig_temp(yCount) = RFbest.sig;
        r_temp(yCount) = tmp(1,2);
    end
    
    RFx(:,xCount) = RFx_temp;
    RFy(:,xCount) = RFy_temp;
    RFsig(:,xCount) = RFsig_temp;
    r(:,xCount) = r_temp;

%    timeLeftBar(h,find(xVox==xVoxRange),length(xVoxRange))
    
%     ang = atan2(RFx,RFy);
%     rad = sqrt(RFx.^2+RFy.^2);
%     
%     figure(1)
%     showMap([],rad,r>cothresh);
%     title('Eccentricity');
%     
%     figure(2)
%     showMap([],ang,r>cothresh);
%     title('Polar Angle');
%     
%     figure(3)
%     showMap([],RFsig*180/pi,r>cothresh);
%     title('Size');
%     drawnow
%     
%         figure(4)
%     showMap([],r,r>0,[0,1]);
%     title('r');
%     drawnow
    
end
% t = toc
 
% save Results RFx RFy RFsig r xVoxRange yVoxRange RFbest


